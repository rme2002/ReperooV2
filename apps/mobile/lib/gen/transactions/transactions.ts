/**
 * Generated by orval v7.17.0 ðŸº
 * Do not edit manually.
 * Core API
 * Core API
 * OpenAPI spec version: 0.0.1
 */
import type {
  CreateExpenseTransactionPayload,
  CreateIncomeTransactionPayload,
  ErrorResponse400Response,
  ErrorResponse401Response,
  ErrorResponse404Response,
  ErrorResponse500Response,
  ListTransactions200Item,
  ListTransactionsParams,
  TransactionExpense,
  TransactionIncome,
  Uid,
  UpdateTransaction200,
  UpdateTransactionPayload
} from '.././model';

import { customFetch } from '.././customFetch';

/**
 * Create a new expense transaction in the transactions table
 * @summary Create expense transaction
 */
export type createExpenseTransactionResponse201 = {
  data: TransactionExpense
  status: 201
}

export type createExpenseTransactionResponse400 = {
  data: ErrorResponse400Response
  status: 400
}

export type createExpenseTransactionResponse401 = {
  data: ErrorResponse401Response
  status: 401
}

export type createExpenseTransactionResponse500 = {
  data: ErrorResponse500Response
  status: 500
}
    
export type createExpenseTransactionResponseSuccess = (createExpenseTransactionResponse201) & {
  headers: Headers;
};
export type createExpenseTransactionResponseError = (createExpenseTransactionResponse400 | createExpenseTransactionResponse401 | createExpenseTransactionResponse500) & {
  headers: Headers;
};

export type createExpenseTransactionResponse = (createExpenseTransactionResponseSuccess | createExpenseTransactionResponseError)

export const getCreateExpenseTransactionUrl = () => {


  

  return `http://example.com/api/v1/transactions/create-expense`
}

export const createExpenseTransaction = async (createExpenseTransactionPayload: CreateExpenseTransactionPayload, options?: RequestInit): Promise<createExpenseTransactionResponse> => {
  
  return customFetch<createExpenseTransactionResponse>(getCreateExpenseTransactionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createExpenseTransactionPayload,)
  }
);}


/**
 * Create a new income transaction in the transactions table
 * @summary Create income transaction
 */
export type createIncomeTransactionResponse201 = {
  data: TransactionIncome
  status: 201
}

export type createIncomeTransactionResponse400 = {
  data: ErrorResponse400Response
  status: 400
}

export type createIncomeTransactionResponse401 = {
  data: ErrorResponse401Response
  status: 401
}

export type createIncomeTransactionResponse500 = {
  data: ErrorResponse500Response
  status: 500
}
    
export type createIncomeTransactionResponseSuccess = (createIncomeTransactionResponse201) & {
  headers: Headers;
};
export type createIncomeTransactionResponseError = (createIncomeTransactionResponse400 | createIncomeTransactionResponse401 | createIncomeTransactionResponse500) & {
  headers: Headers;
};

export type createIncomeTransactionResponse = (createIncomeTransactionResponseSuccess | createIncomeTransactionResponseError)

export const getCreateIncomeTransactionUrl = () => {


  

  return `http://example.com/api/v1/transactions/create-income`
}

export const createIncomeTransaction = async (createIncomeTransactionPayload: CreateIncomeTransactionPayload, options?: RequestInit): Promise<createIncomeTransactionResponse> => {
  
  return customFetch<createIncomeTransactionResponse>(getCreateIncomeTransactionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createIncomeTransactionPayload,)
  }
);}


/**
 * List all transactions for the current user within a date range. This endpoint automatically materializes recurring transactions before returning the list.
 * @summary List transactions
 */
export type listTransactionsResponse200 = {
  data: ListTransactions200Item[]
  status: 200
}

export type listTransactionsResponse401 = {
  data: ErrorResponse401Response
  status: 401
}

export type listTransactionsResponse500 = {
  data: ErrorResponse500Response
  status: 500
}
    
export type listTransactionsResponseSuccess = (listTransactionsResponse200) & {
  headers: Headers;
};
export type listTransactionsResponseError = (listTransactionsResponse401 | listTransactionsResponse500) & {
  headers: Headers;
};

export type listTransactionsResponse = (listTransactionsResponseSuccess | listTransactionsResponseError)

export const getListTransactionsUrl = (params: ListTransactionsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://example.com/api/v1/transactions/list?${stringifiedParams}` : `http://example.com/api/v1/transactions/list`
}

export const listTransactions = async (params: ListTransactionsParams, options?: RequestInit): Promise<listTransactionsResponse> => {
  
  return customFetch<listTransactionsResponse>(getListTransactionsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}


/**
 * Update an existing transaction (partial update). Transaction type cannot be changed.
 * @summary Update transaction
 */
export type updateTransactionResponse200 = {
  data: UpdateTransaction200
  status: 200
}

export type updateTransactionResponse400 = {
  data: ErrorResponse400Response
  status: 400
}

export type updateTransactionResponse401 = {
  data: ErrorResponse401Response
  status: 401
}

export type updateTransactionResponse404 = {
  data: ErrorResponse404Response
  status: 404
}

export type updateTransactionResponse500 = {
  data: ErrorResponse500Response
  status: 500
}
    
export type updateTransactionResponseSuccess = (updateTransactionResponse200) & {
  headers: Headers;
};
export type updateTransactionResponseError = (updateTransactionResponse400 | updateTransactionResponse401 | updateTransactionResponse404 | updateTransactionResponse500) & {
  headers: Headers;
};

export type updateTransactionResponse = (updateTransactionResponseSuccess | updateTransactionResponseError)

export const getUpdateTransactionUrl = (id: Uid,) => {


  

  return `http://example.com/api/v1/transactions/update/${id}`
}

export const updateTransaction = async (id: Uid,
    updateTransactionPayload: UpdateTransactionPayload, options?: RequestInit): Promise<updateTransactionResponse> => {
  
  return customFetch<updateTransactionResponse>(getUpdateTransactionUrl(id),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updateTransactionPayload,)
  }
);}


/**
 * Delete an existing transaction
 * @summary Delete transaction
 */
export type deleteTransactionResponse204 = {
  data: void
  status: 204
}

export type deleteTransactionResponse401 = {
  data: ErrorResponse401Response
  status: 401
}

export type deleteTransactionResponse404 = {
  data: ErrorResponse404Response
  status: 404
}

export type deleteTransactionResponse500 = {
  data: ErrorResponse500Response
  status: 500
}
    
export type deleteTransactionResponseSuccess = (deleteTransactionResponse204) & {
  headers: Headers;
};
export type deleteTransactionResponseError = (deleteTransactionResponse401 | deleteTransactionResponse404 | deleteTransactionResponse500) & {
  headers: Headers;
};

export type deleteTransactionResponse = (deleteTransactionResponseSuccess | deleteTransactionResponseError)

export const getDeleteTransactionUrl = (id: Uid,) => {


  

  return `http://example.com/api/v1/transactions/delete/${id}`
}

export const deleteTransaction = async (id: Uid, options?: RequestInit): Promise<deleteTransactionResponse> => {
  
  return customFetch<deleteTransactionResponse>(getDeleteTransactionUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}


